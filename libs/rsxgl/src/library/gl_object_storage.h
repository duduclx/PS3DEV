//-*-C++-*-
///////////////////////////////////////////////////////////////////
//
// RSXGL - Graphics library for the PS3 GPU.
//
// Copyright (c) 2011 Alexander Betts (alex.betts@gmail.com)
//
// gl_object_storage.h - Store objects associated with integral names.
//
// The following classes implement the OpenGL 3.1 object model, where
// objects (such as shading programs) are created and associated 
// with integer names generated by the library. For some object types,
// names are generated separately from creating the objects
// themselves; these classes support that pattern.
//
// Objects are stored contigously in C-style arrays that grow as
// new objects are added. Instances of the classes contained herein
// "own" the objects, handling their destruction when the objects are
// destroyed or when the namespace array itself goes out of scope.
//
// It's expected that some OpenGL object types may have two parts to
// them - a "hot" part that is used frequently in a rendering loop,
// and a "cold" part that is accessed less frequently (for instance,
// when creating, destroying, or querying the object). To potentially
// make better use of the processor's cache, these two parts may be
// "striped" into separate arrays.
//
// Class striped_gl_object_storage implements all of the object creation
// and storage functionality. Class gl_object_storage is a specialization
// that stores entire objects in one array, and class
// cold_hot_gl_object_storage is a specialization that implements the
// "hot and cold" object composition pattern described above.

#ifndef rsxgl_gl_object_storage_H
#define rsxgl_gl_object_storage_H

#include "array.h"
#include "striped_object_array.h"
#include "name_space.h"

#include <memory>
#include <algorithm>
#include <utility>
#include <limits>
#include <boost/integer.hpp>
#include <boost/integer/integer_mask.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/fusion/include/mpl.hpp>
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/include/at.hpp>
#include <boost/fusion/include/for_each.hpp>
#include <boost/fusion/include/transformation.hpp>

// ObjectsT is a boost::fusion::vector of types:
template< typename ObjectsT,
	  size_t MaxObjects = std::numeric_limits< uint32_t >::max() + 1,
	  int DefaultObject = 0,
	  typename NameBitfieldT = boost::uintmax_t,
	  size_t ObjectAlign = 128,
	  typename Alloc = std::allocator< void > >
class striped_gl_object_storage
{
public:

  typedef name_space< MaxObjects, false, 1 > name_space_type;
  typedef typename name_space_type::name_type name_type;

  name_space_type m_name_space;

  typedef ObjectsT objects_type;

  typedef striped_object_array< ObjectsT, name_type, ObjectAlign > contents_type;
  typename contents_type::pointers_type m_contents, m_orphans;

  typedef typename contents_type::size_type size_type;
  typedef typename contents_type::size_type orphan_size_type;

  size_type m_contents_size;
  orphan_size_type m_orphans_size;

  static const size_type m_contents_grow = 1;
  static const size_type m_orphans_grow = 1;

  orphan_size_type m_num_orphans;

  //
  typename contents_type::type contents() {
    return typename contents_type::type(m_contents,m_contents_size);
  }

  typename contents_type::const_type contents() const {
    return typename contents_type::const_type(m_contents,m_contents_size);
  }

  // Number of objects that can be accommodated without growing the contents array:
  typename contents_type::size_type contents_size() const {
    return m_contents_size;
  }

  // Number of orphans that can be accommodated without growing the contents array:
  typename contents_type::size_type orphans_size() const {
    return m_orphans_size;
  }

  //
  typename contents_type::type orphans() {
    return typename contents_type::type(m_orphans,m_orphans_size);
  }

  typename contents_type::const_type orphans() const {
    return typename contents_type::const_type(m_orphans,m_orphans_size);
  }

  striped_gl_object_storage(const name_type initial_size = 0,void (*init_default_object)(void *) = 0)
    : m_num_orphans(0)
  {
    contents().allocate(std::max((name_type)1,initial_size));
    orphans().allocate(std::max((typename contents_type::size_type)1,initial_size));

    // create object name 0:
    name_type name = create_name();
    rsxgl_assert(name == 0);

    if(DefaultObject) {
      create_object(name);
      if(init_default_object != 0) {
	(*init_default_object)(this);
      }
    }
  }

  ~striped_gl_object_storage() {
    struct created_predicate {
      name_space_type & name_space;

      created_predicate(name_space_type & _name_space)
	: name_space(_name_space) {
      }

      bool operator()(const name_type name) const {
	return name_space.template test_user_bit< 0 >(name);
      }
    } p(m_name_space);

    contents().destruct(p);
    orphans().destruct(p);
  }

  name_type create_name() {
    std::pair< name_type, bool > tmp = m_name_space.create_name();
    rsxgl_assert(tmp.second);
    return tmp.first;
  }

  template< typename OtherNameType >
  size_t create_names(const size_t n,OtherNameType * names) {
    size_t i;
    for(i = 0;i < n;++i,++names) {
      *names = create_name();
    }
    return i;
  }

  // Destroy an object - delete its name, and call the object's destroy() function.
  void destroy(const name_type name) {
    rsxgl_assert(name != 0);

    if(is_name(name)) {
      if(is_constructed(name)) {
	contents().destruct_item(name);
      }

      m_name_space.destroy_name(name);
    }
  }
  
  // Detach an object from its name. The object is not destroyed, and neither is its name
  // reclaimed.
  void detach(const name_type name) {
    rsxgl_assert(name != 0);

    if(is_name(name)) {
      m_name_space.detach_name(name);
    }
  }

  // Orphan the object - make a copy of the object in the orphans list. Client code
  // will later destroy any GPU resources, like memory, that the orphan still occupies.
  std::pair< orphan_size_type, bool > orphan(const name_type name) {
    rsxgl_assert(name != 0);

    if(is_name(name) && is_constructed(name)) {
      // Make room for another orphan:
      if(m_num_orphans >= orphans().size) {
	orphans().resize(m_num_orphans + m_orphans_grow);
      }
      contents_type::move_item(orphans(),m_num_orphans,contents(),name);
      m_name_space.destroy_name(name);

      return std::make_pair(m_num_orphans++,true);
    }
    else {
      return std::make_pair((orphan_size_type)0,false);
    }
  }

  // Destroy accumulated orphans:
  void destroy_orphans() {
    for(size_t i = 0,n = m_num_orphans;i < n;++i) {
      orphans().destruct_item(i);
    }
    m_num_orphans = 0;
  }

  void destroy_orphan(const orphan_size_type i) {
    rsxgl_assert(i < m_num_orphans);
    orphans().destruct_item(i);
    --m_num_orphans;
  }

  void create_object(const name_type name) {
    rsxgl_assert(is_name(name) && !is_constructed(name));

    // Construct the object:
    if(name >= contents().size) {
      contents().resize(name + m_contents_grow);
    }

    contents().construct_item(name);

    m_name_space.template set_user_bit< 0 >(name);
  }

  name_type create_name_and_object() {
    name_type name = create_name();
    create_object(name);
    return name;
  }

  // Returns true if name has been allocated (but may not yet be an actual object):
  bool is_name(const name_type name) const {
    return m_name_space.is_name(name);
  }

  // Returns true if the name has been allocated and its been constructed. For use by
  // functions like glIs*() which test to see if a GL object is fully usable:
  bool is_object(const name_type name) const {
    return m_name_space.is_name(name) && m_name_space.template test_user_bit< 0 >(name);
  }

  // For use by functions that still want to access an object's storage by name, even if it's
  // been glDelete*()'d and should no longer be accessed by other gl*() functions.
  bool is_constructed(const name_type name) const {
    return m_name_space.template test_user_bit< 0 >(name);
  }

  template< size_t I >
  typename boost::add_reference< typename boost::fusion::result_of::at_c< objects_type, I >::type >::type
  at(const name_type i) {
    rsxgl_assert(is_constructed(i));
    rsxgl_assert((DefaultObject == 0) ? (i != 0) : true);
    return contents().template at< I >(i);
  }

  template< size_t I >
  typename boost::add_reference< typename boost::add_const< typename boost::fusion::result_of::at_c< objects_type, I >::type >::type >::type
  at(const name_type i) const {
    rsxgl_assert(is_constructed(i));
    rsxgl_assert((DefaultObject == 0) ? (i != 0) : true);
    return contents().template at< I >(i);
  }

  orphan_size_type num_orphans() const {
    return m_num_orphans;
  }

  // Access an orphan by its index. Note that the argument to these functions is /not/ a name - it's an
  // index onto the orphan list.
  template< size_t I >
  typename boost::add_reference< typename boost::fusion::result_of::at_c< objects_type, I >::type >::type
  orphan_at(const orphan_size_type i) {
    rsxgl_assert(i < m_num_orphans);
    return orphans().template at< I >(i);
  }

  template< size_t I >
  typename boost::add_reference< typename boost::add_const< typename boost::fusion::result_of::at_c< objects_type, I >::type >::type >::type
  orphan_at(const orphan_size_type i) const {
    rsxgl_assert(i < m_num_orphans);
    return orphans().template at< I >(i);
  }
};

template< typename ObjectT,
	  size_t MaxObjects = std::numeric_limits< uint32_t >::max() + 1,
	  int DefaultObject = 0,
	  typename NameBitfieldT = boost::uintmax_t,

	  size_t ObjectAlign = 128,
	  typename Alloc = std::allocator< void > >
class gl_object_storage : public striped_gl_object_storage< boost::fusion::vector< ObjectT >, MaxObjects, DefaultObject, NameBitfieldT, ObjectAlign, Alloc >
{
public:

  typedef striped_gl_object_storage< boost::fusion::vector< ObjectT >, MaxObjects, DefaultObject, NameBitfieldT, ObjectAlign, Alloc > base_type;
  typedef typename base_type::name_type name_type;

  gl_object_storage(const typename base_type::name_type initial_size = 0,void (*init_default_object)(void *) = 0)
    : base_type(initial_size,init_default_object) {
  }

  ObjectT & at(const typename base_type::name_type i) {
    return base_type::template at< 0 >(i);
  }

  const ObjectT & at(const typename base_type::name_type i) const {
    return base_type::template at< 0 >(i);
  }

  ObjectT & orphan_at(const typename base_type::name_type i) {
    return base_type::template orphan_at< 0 >(i);
  }

  const ObjectT & orphan_at(const typename base_type::name_type i) const {
    return base_type::template orphan_at< 0 >(i);
  }
};

#if 0
// This is presently unused by the library. It's meant for objects that can be divided into
// two parts - a "hot" part that's used by critical sections of the program (e.g., the rendering
// loop) and a "cold" part that's used less frequently (e.g., to support OpenGL's ability to 
// query objects, which a program may not do at all). The storage for each object is similarly
// divided into two arrays, and, in an attempt to promote memory locality, the hot parts are
// kept together away from the cold parts (just like a McDLT).

template< typename ColdT, typename HotT >
struct cold_hot_gl_object_destroy {
  void operator()(ColdT & object) const {
    object.destroy();
  }

  void operator()(HotT & object) const {
    object.destroy();
  }
};

template< typename ColdT, typename HotT,
	  size_t MaxObjects = std::numeric_limits< uint32_t >::max() + 1,
	  int DefaultObject = 0,
	  typename NameBitfieldT = boost::uintmax_t,
	  size_t ObjectAlign = 128,
	  typename Alloc = std::allocator< void > >
class cold_hot_gl_object_storage : public striped_gl_object_storage< boost::fusion::vector< ColdT, HotT >, MaxObjects, DefaultObject, ObjectAlign, Alloc >
{
public:

  typedef striped_gl_object_storage< boost::fusion::vector< ColdT, HotT >, MaxObjects, DefaultObject > base_type;
  typedef typename base_type::name_type name_type;

  cold_hot_gl_object_storage(const typename base_type::name_type initial_size = 0,void (*init_default_object)(void *) = 0)
    : base_type(initial_size,init_default_object) {
  }

  ColdT & cold(const typename base_type::name_type i) {
    return base_type::template at< 0 >(i);
  }

  const ColdT & cold(const typename base_type::name_type i) const {
    return base_type::template at< 0 >(i);
  }

  HotT & hot(const typename base_type::name_type i) {
    return base_type::template at< 1 >(i);
  }

  const HotT & hot(const typename base_type::name_type i) const {
    return base_type::template at< 1 >(i);
  }
};
#endif

#endif
